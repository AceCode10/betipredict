// Prisma schema for BetiPredict - PostgreSQL (Supabase)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                      String   @id @default(cuid())
  email                   String   @unique
  password                String?
  phone                   String?  @unique
  username                String   @unique
  fullName                String
  avatar                  String?
  balance                 Float    @default(0)
  isVerified              Boolean  @default(false)
  verificationToken       String?  @unique
  verificationTokenExpiry DateTime?
  resetPasswordToken      String?  @unique
  resetPasswordExpiry     DateTime?
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  orders                  Order[]
  positions               Position[]
  transactions            Transaction[]
  mobilePayments          MobilePayment[]
  marketCreations         Market[]
  suggestions             MarketSuggestion[] @relation("UserSuggestions")
  reviewedSuggestions     MarketSuggestion[] @relation("AdminReviews")
  notifications           Notification[]
  settings                UserSettings?
  disputes                MarketDispute[]    @relation("UserDisputes")
  disputeResolutions      MarketDispute[]    @relation("AdminDisputeResolutions")
  chatMessages            ChatMessage[]
  chatMessageLikes        ChatMessageLike[]

  @@map("users")
}

model Market {
  id              String    @id @default(cuid())
  title           String
  description     String?
  category        String
  subcategory     String?
  question        String    @unique
  yesPrice        Float     @default(0.5)
  noPrice         Float     @default(0.5)
  volume          Float     @default(0)
  liquidity       Float     @default(0)
  status          String    @default("PENDING") // PENDING, ACTIVE, RESOLVED, DISPUTED, FINALIZED, CANCELLED
  resolveTime     DateTime
  resolvedAt      DateTime?
  winningOutcome  String?
  disputeDeadline DateTime? // End of challenge window (24h after resolution)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  creatorId       String
  creator         User      @relation(fields: [creatorId], references: [id])
  orders          Order[]
  positions       Position[]
  disputes        MarketDispute[]
  chatMessages    ChatMessage[]

  @@map("markets")
}

model Order {
  id            String   @id @default(cuid())
  type          String   @default("LIMIT")
  side          String
  outcome       String
  price         Float
  amount        Float
  filled        Float    @default(0)
  remaining     Float
  status        String   @default("OPEN")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userId        String
  user          User     @relation(fields: [userId], references: [id])
  marketId      String
  market        Market   @relation(fields: [marketId], references: [id])

  @@map("orders")
}

model Position {
  id            String   @id @default(cuid())
  outcome       String
  size          Float
  averagePrice  Float
  unrealizedPnl Float    @default(0)
  realizedPnl   Float    @default(0)
  isClosed      Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userId        String
  user          User     @relation(fields: [userId], references: [id])
  marketId      String
  market        Market   @relation(fields: [marketId], references: [id])

  @@unique([userId, marketId, outcome])
  @@map("positions")
}

model Transaction {
  id            String   @id @default(cuid())
  type          String
  amount        Float
  feeAmount     Float    @default(0)
  description   String
  status        String   @default("PENDING")
  metadata      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  userId        String
  user          User     @relation(fields: [userId], references: [id])

  @@map("transactions")
}

// Mobile money payments (Airtel Money deposits & withdrawals)
model MobilePayment {
  id                String   @id @default(cuid())
  type              String   // DEPOSIT or WITHDRAWAL
  amount            Float    // Gross amount in Kwacha
  feeAmount         Float    @default(0) // Platform fee
  netAmount         Float    // Amount after fees
  phoneNumber       String   // Masked phone number (097****567)
  provider          String   @default("AIRTEL_MONEY") // Payment provider
  externalRef       String   @unique // Our reference sent to Airtel (BP-DEP-xxx)
  externalId        String?  // Airtel's transaction ID
  status            String   @default("PENDING") // PENDING, PROCESSING, COMPLETED, FAILED, CANCELLED
  statusMessage     String?
  callbackReceived  Boolean  @default(false)
  callbackData      String?  // Raw callback JSON for audit
  settledAt         DateTime? // When financial settlement (credit/refund) was applied â€” prevents double-settlement
  expiresAt         DateTime // Payment expires after 5 minutes
  completedAt       DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  userId            String
  user              User     @relation(fields: [userId], references: [id])

  @@index([externalRef])
  @@index([userId, type, status])
  @@index([status, expiresAt])
  @@map("mobile_payments")
}

// Platform revenue tracking (all fees collected)
model PlatformRevenue {
  id            String   @id @default(cuid())
  feeType       String   // TRADE_FEE, WITHDRAWAL_FEE, MARKET_CREATION_FEE, RESOLUTION_FEE
  amount        Float    // Fee amount in Kwacha
  description   String
  sourceType    String   // TRADE, WITHDRAWAL, MARKET_CREATION, RESOLUTION
  sourceId      String?  // Reference to the source record (order ID, payment ID, etc.)
  userId        String?  // User who paid the fee (null for system-generated)
  createdAt     DateTime @default(now())

  @@index([feeType])
  @@index([createdAt])
  @@map("platform_revenue")
}

// Scheduled games fetched from sports API (football-data.org)
model ScheduledGame {
  id              String   @id @default(cuid())
  externalId      Int      @unique // API's match ID
  competition     String   // e.g. "Premier League", "La Liga"
  competitionCode String   // e.g. "PL", "PD"
  homeTeam        String
  homeTeamCrest   String?
  awayTeam        String
  awayTeamCrest   String?
  matchday        Int?
  utcDate         DateTime // Scheduled kickoff time
  status          String   // SCHEDULED, LIVE, FINISHED, POSTPONED
  homeScore       Int?
  awayScore       Int?
  winner          String?  // HOME_TEAM, AWAY_TEAM, DRAW, null
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  marketId        String?  @unique // Link to market if one was created
  
  @@map("scheduled_games")
}

// Market suggestions submitted by users (requires admin approval)
model MarketSuggestion {
  id              String   @id @default(cuid())
  title           String
  description     String?
  category        String
  question        String
  resolutionSource String? // How to verify the outcome
  status          String   @default("PENDING") // PENDING, APPROVED, REJECTED
  rejectionReason String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  suggesterId     String
  suggester       User     @relation("UserSuggestions", fields: [suggesterId], references: [id])
  reviewedById    String?
  reviewedBy      User?    @relation("AdminReviews", fields: [reviewedById], references: [id])
  reviewedAt      DateTime?
  marketId        String?  @unique // Link to market if approved and created

  @@map("market_suggestions")
}

// User notifications
model Notification {
  id          String   @id @default(cuid())
  type        String   // MARKET_RESOLVED, BET_WON, BET_LOST, SUGGESTION_APPROVED, SUGGESTION_REJECTED, DEPOSIT, WITHDRAW
  title       String
  message     String
  isRead      Boolean  @default(false)
  metadata    String?  // JSON string for additional data
  createdAt   DateTime @default(now())

  userId      String
  user        User     @relation(fields: [userId], references: [id])

  @@map("notifications")
}

// User settings (dark mode, etc.)
model UserSettings {
  id          String   @id @default(cuid())
  darkMode    Boolean  @default(true)
  language    String   @default("en")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id])

  @@map("user_settings")
}

// Market dispute / challenge (24h window after resolution)
model MarketDispute {
  id              String   @id @default(cuid())
  reason          String   // User's reason for disputing
  evidence        String?  // Optional evidence/link
  status          String   @default("OPEN") // OPEN, UPHELD, REJECTED
  adminResponse   String?  // Admin's resolution response
  resolvedAt      DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  marketId        String
  market          Market   @relation(fields: [marketId], references: [id])
  disputerId      String
  disputer        User     @relation("UserDisputes", fields: [disputerId], references: [id])
  resolvedById    String?
  resolvedBy      User?    @relation("AdminDisputeResolutions", fields: [resolvedById], references: [id])

  @@map("market_disputes")
}

// Idempotency keys for payment deduplication (DB-backed, survives restarts)
model IdempotencyKey {
  id          String   @id @default(cuid())
  key         String   @unique
  status      String   @default("processing") // processing, completed
  httpStatus  Int?
  responseBody String?  // JSON-serialized cached response
  createdAt   DateTime @default(now())
  expiresAt   DateTime // TTL: 24h from creation

  @@index([expiresAt])
  @@map("idempotency_keys")
}

// Market chat messages
model ChatMessage {
  id          String   @id @default(cuid())
  content     String
  parentId    String?  // Reply to another message
  parent      ChatMessage?  @relation("ChatReplies", fields: [parentId], references: [id])
  replies     ChatMessage[] @relation("ChatReplies")
  likes       ChatMessageLike[]
  createdAt   DateTime @default(now())

  userId      String
  user        User     @relation(fields: [userId], references: [id])
  marketId    String
  market      Market   @relation(fields: [marketId], references: [id])

  @@index([marketId, createdAt])
  @@index([parentId])
  @@map("chat_messages")
}

// Chat message likes
model ChatMessageLike {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())

  userId      String
  user        User     @relation(fields: [userId], references: [id])
  messageId   String
  message     ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([userId, messageId])
  @@map("chat_message_likes")
}

// Audit log for admin actions and financial operations
model AuditLog {
  id          String   @id @default(cuid())
  action      String   // e.g. MARKET_RESOLVED, DISPUTE_RESOLVED, USER_BANNED, WITHDRAWAL_APPROVED
  category    String   // MARKET, PAYMENT, USER, SYSTEM
  details     String   // JSON string with action details
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  actorId     String?  // User who performed the action (null for system)

  @@index([action])
  @@index([category])
  @@index([actorId])
  @@index([createdAt])
  @@map("audit_logs")
}
